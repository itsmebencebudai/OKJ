import "./chunk-Y4MX6R6N.js";

// node_modules/sweetalert2/src/utils/params.js
var params_default = {
  title: "",
  titleText: "",
  text: "",
  html: "",
  type: null,
  customClass: "",
  target: "body",
  animation: true,
  allowOutsideClick: true,
  allowEscapeKey: true,
  allowEnterKey: true,
  showConfirmButton: true,
  showCancelButton: false,
  preConfirm: null,
  confirmButtonText: "OK",
  confirmButtonAriaLabel: "",
  confirmButtonColor: "#3085d6",
  confirmButtonClass: null,
  cancelButtonText: "Cancel",
  cancelButtonAriaLabel: "",
  cancelButtonColor: "#aaa",
  cancelButtonClass: null,
  buttonsStyling: true,
  reverseButtons: false,
  focusConfirm: true,
  focusCancel: false,
  showCloseButton: false,
  closeButtonAriaLabel: "Close this dialog",
  showLoaderOnConfirm: false,
  imageUrl: null,
  imageWidth: null,
  imageHeight: null,
  imageAlt: "",
  imageClass: null,
  timer: null,
  width: 500,
  padding: 20,
  background: "#fff",
  input: null,
  inputPlaceholder: "",
  inputValue: "",
  inputOptions: {},
  inputAutoTrim: true,
  inputClass: null,
  inputAttributes: {},
  inputValidator: null,
  grow: false,
  position: "center",
  progressSteps: [],
  currentProgressStep: null,
  progressStepsDistance: "40px",
  onBeforeOpen: null,
  onOpen: null,
  onClose: null,
  useRejections: true
};

// node_modules/sweetalert2/src/utils/classes.js
var swalPrefix = "swal2-";
var prefix = (items) => {
  const result = {};
  for (const i in items) {
    result[items[i]] = swalPrefix + items[i];
  }
  return result;
};
var swalClasses = prefix([
  "container",
  "shown",
  "iosfix",
  "modal",
  "overlay",
  "fade",
  "show",
  "hide",
  "noanimation",
  "close",
  "title",
  "content",
  "buttonswrapper",
  "confirm",
  "cancel",
  "icon",
  "image",
  "input",
  "file",
  "range",
  "select",
  "radio",
  "checkbox",
  "textarea",
  "inputerror",
  "validationerror",
  "progresssteps",
  "activeprogressstep",
  "progresscircle",
  "progressline",
  "loading",
  "styled",
  "top",
  "top-left",
  "top-right",
  "center",
  "center-left",
  "center-right",
  "bottom",
  "bottom-left",
  "bottom-right",
  "grow-row",
  "grow-column",
  "grow-fullscreen"
]);
var iconTypes = prefix([
  "success",
  "warning",
  "info",
  "question",
  "error"
]);

// node_modules/sweetalert2/src/utils/utils.js
var consolePrefix = "SweetAlert2:";
var colorLuminance = (hex, lum) => {
  hex = String(hex).replace(/[^0-9a-f]/gi, "");
  if (hex.length < 6) {
    hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
  }
  lum = lum || 0;
  let rgb = "#";
  for (let i = 0; i < 3; i++) {
    let c = parseInt(hex.substr(i * 2, 2), 16);
    c = Math.round(Math.min(Math.max(0, c + c * lum), 255)).toString(16);
    rgb += ("00" + c).substr(c.length);
  }
  return rgb;
};
var uniqueArray = (arr) => {
  const result = [];
  for (var i in arr) {
    if (result.indexOf(arr[i]) === -1) {
      result.push(arr[i]);
    }
  }
  return result;
};
var warn = (message) => {
  console.warn(`${consolePrefix} ${message}`);
};
var error = (message) => {
  console.error(`${consolePrefix} ${message}`);
};

// node_modules/sweetalert2/src/utils/dom.js
var states = {
  previousWindowKeyDown: null,
  previousActiveElement: null,
  previousBodyPadding: null
};
var init = (params) => {
  const c = getContainer();
  if (c) {
    c.parentNode.removeChild(c);
  }
  if (typeof document === "undefined") {
    error("SweetAlert2 requires document to initialize");
    return;
  }
  const container = document.createElement("div");
  container.className = swalClasses.container;
  container.innerHTML = sweetHTML;
  let targetElement = typeof params.target === "string" ? document.querySelector(params.target) : params.target;
  targetElement.appendChild(container);
  const modal = getModal();
  const input = getChildByClass(modal, swalClasses.input);
  const file = getChildByClass(modal, swalClasses.file);
  const range = modal.querySelector(`.${swalClasses.range} input`);
  const rangeOutput = modal.querySelector(`.${swalClasses.range} output`);
  const select = getChildByClass(modal, swalClasses.select);
  const checkbox = modal.querySelector(`.${swalClasses.checkbox} input`);
  const textarea = getChildByClass(modal, swalClasses.textarea);
  input.oninput = () => {
    sweetalert2_default.resetValidationError();
  };
  file.onchange = () => {
    sweetalert2_default.resetValidationError();
  };
  range.oninput = () => {
    sweetalert2_default.resetValidationError();
    rangeOutput.value = range.value;
  };
  range.onchange = () => {
    sweetalert2_default.resetValidationError();
    range.previousSibling.value = range.value;
  };
  select.onchange = () => {
    sweetalert2_default.resetValidationError();
  };
  checkbox.onchange = () => {
    sweetalert2_default.resetValidationError();
  };
  textarea.oninput = () => {
    sweetalert2_default.resetValidationError();
  };
  return modal;
};
var sweetHTML = `
 <div role="dialog" aria-modal="true" aria-labelledby="${swalClasses.title}" aria-describedby="${swalClasses.content}" class="${swalClasses.modal}" tabindex="-1">
   <ul class="${swalClasses.progresssteps}"></ul>
   <div class="${swalClasses.icon} ${iconTypes.error}">
     <span class="swal2-x-mark"><span class="swal2-x-mark-line-left"></span><span class="swal2-x-mark-line-right"></span></span>
   </div>
   <div class="${swalClasses.icon} ${iconTypes.question}">?</div>
   <div class="${swalClasses.icon} ${iconTypes.warning}">!</div>
   <div class="${swalClasses.icon} ${iconTypes.info}">i</div>
   <div class="${swalClasses.icon} ${iconTypes.success}">
     <div class="swal2-success-circular-line-left"></div>
     <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>
     <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>
     <div class="swal2-success-circular-line-right"></div>
   </div>
   <img class="${swalClasses.image}" />
   <h2 class="${swalClasses.title}" id="${swalClasses.title}"></h2>
   <div id="${swalClasses.content}" class="${swalClasses.content}"></div>
   <input class="${swalClasses.input}" />
   <input type="file" class="${swalClasses.file}" />
   <div class="${swalClasses.range}">
     <output></output>
     <input type="range" />
   </div>
   <select class="${swalClasses.select}"></select>
   <div class="${swalClasses.radio}"></div>
   <label for="${swalClasses.checkbox}" class="${swalClasses.checkbox}">
     <input type="checkbox" />
   </label>
   <textarea class="${swalClasses.textarea}"></textarea>
   <div class="${swalClasses.validationerror}" id="${swalClasses.validationerror}"></div>
   <div class="${swalClasses.buttonswrapper}">
     <button type="button" class="${swalClasses.confirm}">OK</button>
     <button type="button" class="${swalClasses.cancel}">Cancel</button>
   </div>
   <button type="button" class="${swalClasses.close}">Ã—</button>
 </div>
`.replace(/(^|\n)\s*/g, "");
var getContainer = () => document.body.querySelector("." + swalClasses.container);
var getModal = () => getContainer() ? getContainer().querySelector("." + swalClasses.modal) : null;
var getIcons = () => {
  const modal = getModal();
  return modal.querySelectorAll("." + swalClasses.icon);
};
var elementByClass = (className) => getContainer() ? getContainer().querySelector("." + className) : null;
var getTitle = () => elementByClass(swalClasses.title);
var getContent = () => elementByClass(swalClasses.content);
var getImage = () => elementByClass(swalClasses.image);
var getProgressSteps = () => elementByClass(swalClasses.progresssteps);
var getValidationError = () => elementByClass(swalClasses.validationerror);
var getConfirmButton = () => elementByClass(swalClasses.confirm);
var getCancelButton = () => elementByClass(swalClasses.cancel);
var getButtonsWrapper = () => elementByClass(swalClasses.buttonswrapper);
var getCloseButton = () => elementByClass(swalClasses.close);
var getFocusableElements = () => {
  const focusableElementsWithTabindex = Array.from(
    getModal().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')
  ).sort((a, b) => {
    a = parseInt(a.getAttribute("tabindex"));
    b = parseInt(b.getAttribute("tabindex"));
    if (a > b) {
      return 1;
    } else if (a < b) {
      return -1;
    }
    return 0;
  });
  const otherFocusableElements = Array.prototype.slice.call(
    getModal().querySelectorAll('button, input:not([type=hidden]), textarea, select, a, [tabindex="0"]')
  );
  return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements));
};
var hasClass = (elem, className) => {
  if (elem.classList) {
    return elem.classList.contains(className);
  }
  return false;
};
var focusInput = (input) => {
  input.focus();
  if (input.type !== "file") {
    const val = input.value;
    input.value = "";
    input.value = val;
  }
};
var addClass = (elem, className) => {
  if (!elem || !className) {
    return;
  }
  const classes = className.split(/\s+/).filter(Boolean);
  classes.forEach((className2) => {
    elem.classList.add(className2);
  });
};
var removeClass = (elem, className) => {
  if (!elem || !className) {
    return;
  }
  const classes = className.split(/\s+/).filter(Boolean);
  classes.forEach((className2) => {
    elem.classList.remove(className2);
  });
};
var getChildByClass = (elem, className) => {
  for (let i = 0; i < elem.childNodes.length; i++) {
    if (hasClass(elem.childNodes[i], className)) {
      return elem.childNodes[i];
    }
  }
};
var show = (elem, display) => {
  if (!display) {
    display = "block";
  }
  elem.style.opacity = "";
  elem.style.display = display;
};
var hide = (elem) => {
  elem.style.opacity = "";
  elem.style.display = "none";
};
var empty = (elem) => {
  while (elem.firstChild) {
    elem.removeChild(elem.firstChild);
  }
};
var isVisible = (elem) => elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length;
var removeStyleProperty = (elem, property) => {
  if (elem.style.removeProperty) {
    elem.style.removeProperty(property);
  } else {
    elem.style.removeAttribute(property);
  }
};
var animationEndEvent = (() => {
  const testEl = document.createElement("div");
  const transEndEventNames = {
    "WebkitAnimation": "webkitAnimationEnd",
    "OAnimation": "oAnimationEnd oanimationend",
    "animation": "animationend"
  };
  for (const i in transEndEventNames) {
    if (transEndEventNames.hasOwnProperty(i) && testEl.style[i] !== void 0) {
      return transEndEventNames[i];
    }
  }
  return false;
})();
var resetPrevState = () => {
  window.onkeydown = states.previousWindowKeyDown;
  if (states.previousActiveElement && states.previousActiveElement.focus) {
    let x = window.scrollX;
    let y = window.scrollY;
    states.previousActiveElement.focus();
    if (x && y) {
      window.scrollTo(x, y);
    }
  }
};
var measureScrollbar = () => {
  const supportsTouch = "ontouchstart" in window || navigator.msMaxTouchPoints;
  if (supportsTouch) {
    return 0;
  }
  const scrollDiv = document.createElement("div");
  scrollDiv.style.width = "50px";
  scrollDiv.style.height = "50px";
  scrollDiv.style.overflow = "scroll";
  document.body.appendChild(scrollDiv);
  const scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  document.body.removeChild(scrollDiv);
  return scrollbarWidth;
};

// node_modules/sweetalert2/src/sweetalert2.js
var modalParams = Object.assign({}, params_default);
var queue = [];
if (typeof Promise === "undefined") {
  error("This package requires a Promise library, please include a shim to enable it in this browser (See: https://github.com/limonte/sweetalert2/wiki/Migration-from-SweetAlert-to-SweetAlert2#1-ie-support)");
}
var setParameters = (params) => {
  if (typeof params.target === "string" && !document.querySelector(params.target) || typeof params.target !== "string" && !params.target.appendChild) {
    warn('Target parameter is not valid, defaulting to "body"');
    params.target = "body";
  }
  let modal;
  const oldModal = getModal();
  let targetElement = typeof params.target === "string" ? document.querySelector(params.target) : params.target;
  if (oldModal && targetElement && oldModal.parentNode !== targetElement.parentNode) {
    modal = init(params);
  } else {
    modal = oldModal || init(params);
  }
  for (let param in params) {
    if (!sweetAlert.isValidParameter(param)) {
      warn(`Unknown parameter "${param}"`);
    }
  }
  modal.style.width = typeof params.width === "number" ? params.width + "px" : params.width;
  modal.style.padding = params.padding + "px";
  modal.style.background = params.background;
  const successIconParts = modal.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");
  for (let i = 0; i < successIconParts.length; i++) {
    successIconParts[i].style.background = params.background;
  }
  const container = getContainer();
  const title = getTitle();
  const content = getContent();
  const buttonsWrapper = getButtonsWrapper();
  const confirmButton = getConfirmButton();
  const cancelButton = getCancelButton();
  const closeButton = getCloseButton();
  if (params.titleText) {
    title.innerText = params.titleText;
  } else {
    title.innerHTML = params.title.split("\n").join("<br />");
  }
  if (params.text || params.html) {
    if (typeof params.html === "object") {
      content.innerHTML = "";
      if (0 in params.html) {
        for (let i = 0; i in params.html; i++) {
          content.appendChild(params.html[i].cloneNode(true));
        }
      } else {
        content.appendChild(params.html.cloneNode(true));
      }
    } else if (params.html) {
      content.innerHTML = params.html;
    } else if (params.text) {
      content.textContent = params.text;
    }
    show(content);
  } else {
    hide(content);
  }
  if (params.position in swalClasses) {
    addClass(container, swalClasses[params.position]);
  }
  if (params.grow && typeof params.grow === "string") {
    let growClass = "grow-" + params.grow;
    if (growClass in swalClasses) {
      addClass(container, swalClasses[growClass]);
    }
  }
  if (params.showCloseButton) {
    closeButton.setAttribute("aria-label", params.closeButtonAriaLabel);
    show(closeButton);
  } else {
    hide(closeButton);
  }
  modal.className = swalClasses.modal;
  if (params.customClass) {
    addClass(modal, params.customClass);
  }
  let progressStepsContainer = getProgressSteps();
  let currentProgressStep = parseInt(params.currentProgressStep === null ? sweetAlert.getQueueStep() : params.currentProgressStep, 10);
  if (params.progressSteps.length) {
    show(progressStepsContainer);
    empty(progressStepsContainer);
    if (currentProgressStep >= params.progressSteps.length) {
      warn(
        "Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)"
      );
    }
    params.progressSteps.forEach((step, index) => {
      let circle = document.createElement("li");
      addClass(circle, swalClasses.progresscircle);
      circle.innerHTML = step;
      if (index === currentProgressStep) {
        addClass(circle, swalClasses.activeprogressstep);
      }
      progressStepsContainer.appendChild(circle);
      if (index !== params.progressSteps.length - 1) {
        let line = document.createElement("li");
        addClass(line, swalClasses.progressline);
        line.style.width = params.progressStepsDistance;
        progressStepsContainer.appendChild(line);
      }
    });
  } else {
    hide(progressStepsContainer);
  }
  const icons = getIcons();
  for (let i = 0; i < icons.length; i++) {
    hide(icons[i]);
  }
  if (params.type) {
    let validType = false;
    for (let iconType in iconTypes) {
      if (params.type === iconType) {
        validType = true;
        break;
      }
    }
    if (!validType) {
      error(`Unknown alert type: ${params.type}`);
      return false;
    }
    const icon = modal.querySelector(`.${swalClasses.icon}.${iconTypes[params.type]}`);
    show(icon);
    if (params.animation) {
      switch (params.type) {
        case "success":
          addClass(icon, "swal2-animate-success-icon");
          addClass(icon.querySelector(".swal2-success-line-tip"), "swal2-animate-success-line-tip");
          addClass(icon.querySelector(".swal2-success-line-long"), "swal2-animate-success-line-long");
          break;
        case "error":
          addClass(icon, "swal2-animate-error-icon");
          addClass(icon.querySelector(".swal2-x-mark"), "swal2-animate-x-mark");
          break;
        default:
          break;
      }
    }
  }
  const image = getImage();
  if (params.imageUrl) {
    image.setAttribute("src", params.imageUrl);
    image.setAttribute("alt", params.imageAlt);
    show(image);
    if (params.imageWidth) {
      image.setAttribute("width", params.imageWidth);
    } else {
      image.removeAttribute("width");
    }
    if (params.imageHeight) {
      image.setAttribute("height", params.imageHeight);
    } else {
      image.removeAttribute("height");
    }
    image.className = swalClasses.image;
    if (params.imageClass) {
      addClass(image, params.imageClass);
    }
  } else {
    hide(image);
  }
  if (params.showCancelButton) {
    cancelButton.style.display = "inline-block";
  } else {
    hide(cancelButton);
  }
  if (params.showConfirmButton) {
    removeStyleProperty(confirmButton, "display");
  } else {
    hide(confirmButton);
  }
  if (!params.showConfirmButton && !params.showCancelButton) {
    hide(buttonsWrapper);
  } else {
    show(buttonsWrapper);
  }
  confirmButton.innerHTML = params.confirmButtonText;
  cancelButton.innerHTML = params.cancelButtonText;
  confirmButton.setAttribute("aria-label", params.confirmButtonAriaLabel);
  cancelButton.setAttribute("aria-label", params.cancelButtonAriaLabel);
  if (params.buttonsStyling) {
    confirmButton.style.backgroundColor = params.confirmButtonColor;
    cancelButton.style.backgroundColor = params.cancelButtonColor;
  }
  confirmButton.className = swalClasses.confirm;
  addClass(confirmButton, params.confirmButtonClass);
  cancelButton.className = swalClasses.cancel;
  addClass(cancelButton, params.cancelButtonClass);
  if (params.buttonsStyling) {
    addClass(confirmButton, swalClasses.styled);
    addClass(cancelButton, swalClasses.styled);
  } else {
    removeClass(confirmButton, swalClasses.styled);
    removeClass(cancelButton, swalClasses.styled);
    confirmButton.style.backgroundColor = confirmButton.style.borderLeftColor = confirmButton.style.borderRightColor = "";
    cancelButton.style.backgroundColor = cancelButton.style.borderLeftColor = cancelButton.style.borderRightColor = "";
  }
  if (params.animation === true) {
    removeClass(modal, swalClasses.noanimation);
  } else {
    addClass(modal, swalClasses.noanimation);
  }
  if (params.showLoaderOnConfirm && !params.preConfirm) {
    warn(
      "showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://limonte.github.io/sweetalert2/#ajax-request"
    );
  }
};
var openModal = (animation, onBeforeOpen, onComplete) => {
  const container = getContainer();
  const modal = getModal();
  if (onBeforeOpen !== null && typeof onBeforeOpen === "function") {
    onBeforeOpen(modal);
  }
  if (animation) {
    addClass(modal, swalClasses.show);
    addClass(container, swalClasses.fade);
    removeClass(modal, swalClasses.hide);
  } else {
    removeClass(modal, swalClasses.fade);
  }
  show(modal);
  container.style.overflowY = "hidden";
  if (animationEndEvent && !hasClass(modal, swalClasses.noanimation)) {
    modal.addEventListener(animationEndEvent, function swalCloseEventFinished() {
      modal.removeEventListener(animationEndEvent, swalCloseEventFinished);
      container.style.overflowY = "auto";
    });
  } else {
    container.style.overflowY = "auto";
  }
  addClass(document.documentElement, swalClasses.shown);
  addClass(document.body, swalClasses.shown);
  addClass(container, swalClasses.shown);
  fixScrollbar();
  iOSfix();
  states.previousActiveElement = document.activeElement;
  if (onComplete !== null && typeof onComplete === "function") {
    setTimeout(function() {
      onComplete(modal);
    });
  }
};
var fixScrollbar = () => {
  if (states.previousBodyPadding !== null) {
    return;
  }
  if (document.body.scrollHeight > window.innerHeight) {
    states.previousBodyPadding = document.body.style.paddingRight;
    document.body.style.paddingRight = measureScrollbar() + "px";
  }
};
var undoScrollbar = () => {
  if (states.previousBodyPadding !== null) {
    document.body.style.paddingRight = states.previousBodyPadding;
    states.previousBodyPadding = null;
  }
};
var iOSfix = () => {
  const iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
  if (iOS && !hasClass(document.body, swalClasses.iosfix)) {
    const offset = document.body.scrollTop;
    document.body.style.top = offset * -1 + "px";
    addClass(document.body, swalClasses.iosfix);
  }
};
var undoIOSfix = () => {
  if (hasClass(document.body, swalClasses.iosfix)) {
    const offset = parseInt(document.body.style.top, 10);
    removeClass(document.body, swalClasses.iosfix);
    document.body.style.top = "";
    document.body.scrollTop = offset * -1;
  }
};
var sweetAlert = (...args) => {
  if (args[0] === void 0) {
    error("SweetAlert2 expects at least 1 attribute!");
    return false;
  }
  let params = Object.assign({}, modalParams);
  switch (typeof args[0]) {
    case "string":
      [params.title, params.html, params.type] = args;
      break;
    case "object":
      Object.assign(params, args[0]);
      params.extraParams = args[0].extraParams;
      if (params.input === "email" && params.inputValidator === null) {
        params.inputValidator = (email) => {
          return new Promise((resolve, reject) => {
            const emailRegex = /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
            if (emailRegex.test(email)) {
              resolve();
            } else {
              reject("Invalid email address");
            }
          });
        };
      }
      if (params.input === "url" && params.inputValidator === null) {
        params.inputValidator = (url) => {
          return new Promise((resolve, reject) => {
            const urlRegex = /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_+.~#?&//=]*)$/;
            if (urlRegex.test(url)) {
              resolve();
            } else {
              reject("Invalid URL");
            }
          });
        };
      }
      break;
    default:
      error('Unexpected type of argument! Expected "string" or "object", got ' + typeof args[0]);
      return false;
  }
  setParameters(params);
  const container = getContainer();
  const modal = getModal();
  return new Promise((resolve, reject) => {
    if (params.timer) {
      modal.timeout = setTimeout(() => {
        sweetAlert.closeModal(params.onClose);
        if (params.useRejections) {
          reject("timer");
        } else {
          resolve({ dismiss: "timer" });
        }
      }, params.timer);
    }
    const getInput = (inputType) => {
      inputType = inputType || params.input;
      if (!inputType) {
        return null;
      }
      switch (inputType) {
        case "select":
        case "textarea":
        case "file":
          return getChildByClass(modal, swalClasses[inputType]);
        case "checkbox":
          return modal.querySelector(`.${swalClasses.checkbox} input`);
        case "radio":
          return modal.querySelector(`.${swalClasses.radio} input:checked`) || modal.querySelector(`.${swalClasses.radio} input:first-child`);
        case "range":
          return modal.querySelector(`.${swalClasses.range} input`);
        default:
          return getChildByClass(modal, swalClasses.input);
      }
    };
    const getInputValue = () => {
      const input2 = getInput();
      if (!input2) {
        return null;
      }
      switch (params.input) {
        case "checkbox":
          return input2.checked ? 1 : 0;
        case "radio":
          return input2.checked ? input2.value : null;
        case "file":
          return input2.files.length ? input2.files[0] : null;
        default:
          return params.inputAutoTrim ? input2.value.trim() : input2.value;
      }
    };
    if (params.input) {
      setTimeout(() => {
        const input2 = getInput();
        if (input2) {
          focusInput(input2);
        }
      }, 0);
    }
    const confirm = (value) => {
      if (params.showLoaderOnConfirm) {
        sweetAlert.showLoading();
      }
      if (params.preConfirm) {
        params.preConfirm(value, params.extraParams).then(
          (preConfirmValue) => {
            sweetAlert.closeModal(params.onClose);
            resolve(preConfirmValue || value);
          },
          (error2) => {
            sweetAlert.hideLoading();
            if (error2) {
              sweetAlert.showValidationError(error2);
            }
          }
        );
      } else {
        sweetAlert.closeModal(params.onClose);
        if (params.useRejections) {
          resolve(value);
        } else {
          resolve({ value });
        }
      }
    };
    const onButtonEvent = (event) => {
      const e = event || window.event;
      const target = e.target || e.srcElement;
      const confirmButton2 = getConfirmButton();
      const cancelButton2 = getCancelButton();
      const targetedConfirm = confirmButton2 && (confirmButton2 === target || confirmButton2.contains(target));
      const targetedCancel = cancelButton2 && (cancelButton2 === target || cancelButton2.contains(target));
      switch (e.type) {
        case "mouseover":
        case "mouseup":
          if (params.buttonsStyling) {
            if (targetedConfirm) {
              confirmButton2.style.backgroundColor = colorLuminance(params.confirmButtonColor, -0.1);
            } else if (targetedCancel) {
              cancelButton2.style.backgroundColor = colorLuminance(params.cancelButtonColor, -0.1);
            }
          }
          break;
        case "mouseout":
          if (params.buttonsStyling) {
            if (targetedConfirm) {
              confirmButton2.style.backgroundColor = params.confirmButtonColor;
            } else if (targetedCancel) {
              cancelButton2.style.backgroundColor = params.cancelButtonColor;
            }
          }
          break;
        case "mousedown":
          if (params.buttonsStyling) {
            if (targetedConfirm) {
              confirmButton2.style.backgroundColor = colorLuminance(params.confirmButtonColor, -0.2);
            } else if (targetedCancel) {
              cancelButton2.style.backgroundColor = colorLuminance(params.cancelButtonColor, -0.2);
            }
          }
          break;
        case "click":
          if (targetedConfirm && sweetAlert.isVisible()) {
            sweetAlert.disableButtons();
            if (params.input) {
              const inputValue = getInputValue();
              if (params.inputValidator) {
                sweetAlert.disableInput();
                params.inputValidator(inputValue, params.extraParams).then(
                  () => {
                    sweetAlert.enableButtons();
                    sweetAlert.enableInput();
                    confirm(inputValue);
                  },
                  (error2) => {
                    sweetAlert.enableButtons();
                    sweetAlert.enableInput();
                    if (error2) {
                      sweetAlert.showValidationError(error2);
                    }
                  }
                );
              } else {
                confirm(inputValue);
              }
            } else {
              confirm(true);
            }
          } else if (targetedCancel && sweetAlert.isVisible()) {
            sweetAlert.disableButtons();
            sweetAlert.closeModal(params.onClose);
            if (params.useRejections) {
              reject("cancel");
            } else {
              resolve({ dismiss: "cancel" });
            }
          }
          break;
        default:
      }
    };
    const buttons = modal.querySelectorAll("button");
    for (let i = 0; i < buttons.length; i++) {
      buttons[i].onclick = onButtonEvent;
      buttons[i].onmouseover = onButtonEvent;
      buttons[i].onmouseout = onButtonEvent;
      buttons[i].onmousedown = onButtonEvent;
    }
    getCloseButton().onclick = () => {
      sweetAlert.closeModal(params.onClose);
      if (params.useRejections) {
        reject("close");
      } else {
        resolve({ dismiss: "close" });
      }
    };
    container.onclick = (e) => {
      if (e.target !== container) {
        return;
      }
      if (params.allowOutsideClick) {
        sweetAlert.closeModal(params.onClose);
        if (params.useRejections) {
          reject("overlay");
        } else {
          resolve({ dismiss: "overlay" });
        }
      }
    };
    const buttonsWrapper = getButtonsWrapper();
    const confirmButton = getConfirmButton();
    const cancelButton = getCancelButton();
    if (params.reverseButtons) {
      confirmButton.parentNode.insertBefore(cancelButton, confirmButton);
    } else {
      confirmButton.parentNode.insertBefore(confirmButton, cancelButton);
    }
    const setFocus = (index, increment) => {
      const focusableElements = getFocusableElements(params.focusCancel);
      for (let i = 0; i < focusableElements.length; i++) {
        index = index + increment;
        if (index === focusableElements.length) {
          index = 0;
        } else if (index === -1) {
          index = focusableElements.length - 1;
        }
        const el = focusableElements[index];
        if (isVisible(el)) {
          return el.focus();
        }
      }
    };
    const handleKeyDown = (event) => {
      const e = event || window.event;
      if (e.key === "Enter") {
        if (e.target === getInput()) {
          if (e.target.tagName.toLowerCase() === "textarea") {
            return;
          }
          sweetAlert.clickConfirm();
          e.preventDefault();
        }
      } else if (e.key === "Tab") {
        const targetElement = e.target || e.srcElement;
        const focusableElements = getFocusableElements(params.focusCancel);
        let btnIndex = -1;
        for (let i = 0; i < focusableElements.length; i++) {
          if (targetElement === focusableElements[i]) {
            btnIndex = i;
            break;
          }
        }
        if (!e.shiftKey) {
          setFocus(btnIndex, 1);
        } else {
          setFocus(btnIndex, -1);
        }
        e.stopPropagation();
        e.preventDefault();
      } else if (["ArrowLeft", "ArrowRight", "ArrowUp", "Arrowdown"].includes(e.key)) {
        if (document.activeElement === confirmButton && isVisible(cancelButton)) {
          cancelButton.focus();
        } else if (document.activeElement === cancelButton && isVisible(confirmButton)) {
          confirmButton.focus();
        }
      } else if ((e.key === "Escape" || e.key === "Esc") && params.allowEscapeKey === true) {
        sweetAlert.closeModal(params.onClose);
        if (params.useRejections) {
          reject("esc");
        } else {
          resolve({ dismiss: "esc" });
        }
      }
    };
    if (!window.onkeydown || window.onkeydown.toString() !== handleKeyDown.toString()) {
      states.previousWindowKeyDown = window.onkeydown;
      window.onkeydown = handleKeyDown;
    }
    if (params.buttonsStyling) {
      confirmButton.style.borderLeftColor = params.confirmButtonColor;
      confirmButton.style.borderRightColor = params.confirmButtonColor;
    }
    sweetAlert.hideLoading = sweetAlert.disableLoading = () => {
      if (!params.showConfirmButton) {
        hide(confirmButton);
        if (!params.showCancelButton) {
          hide(getButtonsWrapper());
        }
      }
      removeClass(buttonsWrapper, swalClasses.loading);
      removeClass(modal, swalClasses.loading);
      modal.removeAttribute("aria-busy");
      confirmButton.disabled = false;
      cancelButton.disabled = false;
    };
    sweetAlert.getTitle = () => getTitle();
    sweetAlert.getContent = () => getContent();
    sweetAlert.getInput = () => getInput();
    sweetAlert.getImage = () => getImage();
    sweetAlert.getButtonsWrapper = () => getButtonsWrapper();
    sweetAlert.getConfirmButton = () => getConfirmButton();
    sweetAlert.getCancelButton = () => getCancelButton();
    sweetAlert.enableButtons = () => {
      confirmButton.disabled = false;
      cancelButton.disabled = false;
    };
    sweetAlert.disableButtons = () => {
      confirmButton.disabled = true;
      cancelButton.disabled = true;
    };
    sweetAlert.enableConfirmButton = () => {
      confirmButton.disabled = false;
    };
    sweetAlert.disableConfirmButton = () => {
      confirmButton.disabled = true;
    };
    sweetAlert.enableInput = () => {
      const input2 = getInput();
      if (!input2) {
        return false;
      }
      if (input2.type === "radio") {
        const radiosContainer = input2.parentNode.parentNode;
        const radios = radiosContainer.querySelectorAll("input");
        for (let i = 0; i < radios.length; i++) {
          radios[i].disabled = false;
        }
      } else {
        input2.disabled = false;
      }
    };
    sweetAlert.disableInput = () => {
      const input2 = getInput();
      if (!input2) {
        return false;
      }
      if (input2 && input2.type === "radio") {
        const radiosContainer = input2.parentNode.parentNode;
        const radios = radiosContainer.querySelectorAll("input");
        for (let i = 0; i < radios.length; i++) {
          radios[i].disabled = true;
        }
      } else {
        input2.disabled = true;
      }
    };
    sweetAlert.showValidationError = (error2) => {
      const validationError = getValidationError();
      validationError.innerHTML = error2;
      show(validationError);
      const input2 = getInput();
      if (input2) {
        input2.setAttribute("aria-invalid", true);
        input2.setAttribute("aria-describedBy", swalClasses.validationerror);
        focusInput(input2);
        addClass(input2, swalClasses.inputerror);
      }
    };
    sweetAlert.resetValidationError = () => {
      const validationError = getValidationError();
      hide(validationError);
      const input2 = getInput();
      if (input2) {
        input2.removeAttribute("aria-invalid");
        input2.removeAttribute("aria-describedBy");
        removeClass(input2, swalClasses.inputerror);
      }
    };
    sweetAlert.getProgressSteps = () => {
      return params.progressSteps;
    };
    sweetAlert.setProgressSteps = (progressSteps) => {
      params.progressSteps = progressSteps;
      setParameters(params);
    };
    sweetAlert.showProgressSteps = () => {
      show(getProgressSteps());
    };
    sweetAlert.hideProgressSteps = () => {
      hide(getProgressSteps());
    };
    sweetAlert.enableButtons();
    sweetAlert.hideLoading();
    sweetAlert.resetValidationError();
    const inputTypes = ["input", "file", "range", "select", "radio", "checkbox", "textarea"];
    let input;
    for (let i = 0; i < inputTypes.length; i++) {
      const inputClass = swalClasses[inputTypes[i]];
      const inputContainer = getChildByClass(modal, inputClass);
      input = getInput(inputTypes[i]);
      if (input) {
        for (let j in input.attributes) {
          if (input.attributes.hasOwnProperty(j)) {
            const attrName = input.attributes[j].name;
            if (attrName !== "type" && attrName !== "value") {
              input.removeAttribute(attrName);
            }
          }
        }
        for (let attr in params.inputAttributes) {
          input.setAttribute(attr, params.inputAttributes[attr]);
        }
      }
      inputContainer.className = inputClass;
      if (params.inputClass) {
        addClass(inputContainer, params.inputClass);
      }
      hide(inputContainer);
    }
    let populateInputOptions;
    switch (params.input) {
      case "text":
      case "email":
      case "password":
      case "number":
      case "tel":
      case "url":
        input = getChildByClass(modal, swalClasses.input);
        input.value = params.inputValue;
        input.placeholder = params.inputPlaceholder;
        input.type = params.input;
        show(input);
        break;
      case "file":
        input = getChildByClass(modal, swalClasses.file);
        input.placeholder = params.inputPlaceholder;
        input.type = params.input;
        show(input);
        break;
      case "range":
        const range = getChildByClass(modal, swalClasses.range);
        const rangeInput = range.querySelector("input");
        const rangeOutput = range.querySelector("output");
        rangeInput.value = params.inputValue;
        rangeInput.type = params.input;
        rangeOutput.value = params.inputValue;
        show(range);
        break;
      case "select":
        const select = getChildByClass(modal, swalClasses.select);
        select.innerHTML = "";
        if (params.inputPlaceholder) {
          const placeholder = document.createElement("option");
          placeholder.innerHTML = params.inputPlaceholder;
          placeholder.value = "";
          placeholder.disabled = true;
          placeholder.selected = true;
          select.appendChild(placeholder);
        }
        populateInputOptions = (inputOptions) => {
          for (let optionValue in inputOptions) {
            const option = document.createElement("option");
            option.value = optionValue;
            option.innerHTML = inputOptions[optionValue];
            if (params.inputValue.toString() === optionValue) {
              option.selected = true;
            }
            select.appendChild(option);
          }
          show(select);
          select.focus();
        };
        break;
      case "radio":
        const radio = getChildByClass(modal, swalClasses.radio);
        radio.innerHTML = "";
        populateInputOptions = (inputOptions) => {
          for (let radioValue in inputOptions) {
            const radioInput = document.createElement("input");
            const radioLabel = document.createElement("label");
            const radioLabelSpan = document.createElement("span");
            radioInput.type = "radio";
            radioInput.name = swalClasses.radio;
            radioInput.value = radioValue;
            if (params.inputValue.toString() === radioValue) {
              radioInput.checked = true;
            }
            radioLabelSpan.innerHTML = inputOptions[radioValue];
            radioLabel.appendChild(radioInput);
            radioLabel.appendChild(radioLabelSpan);
            radioLabel.for = radioInput.id;
            radio.appendChild(radioLabel);
          }
          show(radio);
          const radios = radio.querySelectorAll("input");
          if (radios.length) {
            radios[0].focus();
          }
        };
        break;
      case "checkbox":
        const checkbox = getChildByClass(modal, swalClasses.checkbox);
        const checkboxInput = getInput("checkbox");
        checkboxInput.type = "checkbox";
        checkboxInput.value = 1;
        checkboxInput.id = swalClasses.checkbox;
        checkboxInput.checked = Boolean(params.inputValue);
        let label = checkbox.getElementsByTagName("span");
        if (label.length) {
          checkbox.removeChild(label[0]);
        }
        label = document.createElement("span");
        label.innerHTML = params.inputPlaceholder;
        checkbox.appendChild(label);
        show(checkbox);
        break;
      case "textarea":
        const textarea = getChildByClass(modal, swalClasses.textarea);
        textarea.value = params.inputValue;
        textarea.placeholder = params.inputPlaceholder;
        show(textarea);
        break;
      case null:
        break;
      default:
        error(`Unexpected type of input! Expected "text", "email", "password", "number", "tel", "select", "radio", "checkbox", "textarea", "file" or "url", got "${params.input}"`);
        break;
    }
    if (params.input === "select" || params.input === "radio") {
      if (params.inputOptions instanceof Promise) {
        sweetAlert.showLoading();
        params.inputOptions.then((inputOptions) => {
          sweetAlert.hideLoading();
          populateInputOptions(inputOptions);
        });
      } else if (typeof params.inputOptions === "object") {
        populateInputOptions(params.inputOptions);
      } else {
        error("Unexpected type of inputOptions! Expected object or Promise, got " + typeof params.inputOptions);
      }
    }
    openModal(params.animation, params.onBeforeOpen, params.onOpen);
    if (!params.allowEnterKey) {
      if (document.activeElement) {
        document.activeElement.blur();
      }
    } else if (params.focusCancel && isVisible(cancelButton)) {
      cancelButton.focus();
    } else if (params.focusConfirm && isVisible(confirmButton)) {
      confirmButton.focus();
    } else {
      setFocus(-1, 1);
    }
    getContainer().scrollTop = 0;
  });
};
sweetAlert.isVisible = () => {
  return !!getModal();
};
sweetAlert.queue = (steps) => {
  queue = steps;
  const resetQueue = () => {
    queue = [];
    document.body.removeAttribute("data-swal2-queue-step");
  };
  let queueResult = [];
  return new Promise((resolve, reject) => {
    (function step(i, callback) {
      if (i < queue.length) {
        document.body.setAttribute("data-swal2-queue-step", i);
        sweetAlert(queue[i]).then(
          (result) => {
            queueResult.push(result);
            step(i + 1, callback);
          },
          (dismiss) => {
            resetQueue();
            reject(dismiss);
          }
        );
      } else {
        resetQueue();
        resolve(queueResult);
      }
    })(0);
  });
};
sweetAlert.getQueueStep = () => document.body.getAttribute("data-swal2-queue-step");
sweetAlert.insertQueueStep = (step, index) => {
  if (index && index < queue.length) {
    return queue.splice(index, 0, step);
  }
  return queue.push(step);
};
sweetAlert.deleteQueueStep = (index) => {
  if (typeof queue[index] !== "undefined") {
    queue.splice(index, 1);
  }
};
sweetAlert.close = sweetAlert.closeModal = (onComplete) => {
  const container = getContainer();
  const modal = getModal();
  if (!modal) {
    return;
  }
  removeClass(modal, swalClasses.show);
  addClass(modal, swalClasses.hide);
  clearTimeout(modal.timeout);
  resetPrevState();
  const removeModalAndResetState = () => {
    if (container.parentNode) {
      container.parentNode.removeChild(container);
    }
    removeClass(document.documentElement, swalClasses.shown);
    removeClass(document.body, swalClasses.shown);
    undoScrollbar();
    undoIOSfix();
  };
  if (animationEndEvent && !hasClass(modal, swalClasses.noanimation)) {
    modal.addEventListener(animationEndEvent, function swalCloseEventFinished() {
      modal.removeEventListener(animationEndEvent, swalCloseEventFinished);
      if (hasClass(modal, swalClasses.hide)) {
        removeModalAndResetState();
      }
    });
  } else {
    removeModalAndResetState();
  }
  if (onComplete !== null && typeof onComplete === "function") {
    setTimeout(function() {
      onComplete(modal);
    });
  }
};
sweetAlert.clickConfirm = () => getConfirmButton().click();
sweetAlert.clickCancel = () => getCancelButton().click();
sweetAlert.showLoading = sweetAlert.enableLoading = () => {
  let modal = getModal();
  if (!modal) {
    sweetAlert("");
  }
  modal = getModal();
  const buttonsWrapper = getButtonsWrapper();
  const confirmButton = getConfirmButton();
  const cancelButton = getCancelButton();
  show(buttonsWrapper);
  show(confirmButton, "inline-block");
  addClass(buttonsWrapper, swalClasses.loading);
  addClass(modal, swalClasses.loading);
  confirmButton.disabled = true;
  cancelButton.disabled = true;
  modal.setAttribute("aria-busy", true);
  modal.focus();
};
sweetAlert.isValidParameter = (paramName) => {
  return params_default.hasOwnProperty(paramName) || paramName === "extraParams";
};
sweetAlert.setDefaults = (userParams) => {
  if (!userParams || typeof userParams !== "object") {
    return error("the argument for setDefaults() is required and has to be a object");
  }
  for (let param in userParams) {
    if (!sweetAlert.isValidParameter(param)) {
      warn(`Unknown parameter "${param}"`);
      delete userParams[param];
    }
  }
  Object.assign(modalParams, userParams);
};
sweetAlert.resetDefaults = () => {
  modalParams = Object.assign({}, params_default);
};
sweetAlert.noop = () => {
};
sweetAlert.version = "";
sweetAlert.default = sweetAlert;
var sweetalert2_default = sweetAlert;
export {
  sweetalert2_default as default
};
//# sourceMappingURL=sweetalert2.js.map
